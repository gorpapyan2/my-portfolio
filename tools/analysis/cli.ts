import fs from "fs";
import path from "path";
import { runDetectors } from "./collectors/index.js";
import { groupByModule } from "./grouping.js";
import { writeJsonReport } from "./reporters/json_reporter.js";
import { writeMarkdownReport } from "./reporters/markdown_reporter.js";
import { listFiles, readText } from "./utils/fs.js";
import { AnalysisConfig, Report, RoadmapPhase } from "./types.js";
type Args={command:string;configPath?:string;root?:string;outDir?:string};
const parseArgs=(argv:string[]):Args=>{const[command="scan",...rest]=argv;const args:Args={command};for(let i=0;i<rest.length;i++){const key=rest[i];if(key==="--config")args.configPath=rest[++i];if(key==="--root")args.root=rest[++i];if(key==="--out")args.outDir=rest[++i];}return args;};
const loadConfig=(configPath:string)=>JSON.parse(readText(configPath)) as AnalysisConfig;
const summaryFromModules=(modules:Report["modules"]):Report["summary"]=>{const totalsByType={duplication:0,unused:0,dead:0,deprecated:0,complexity:0,coupling:0,consistency:0};for(const module of modules){for(const issue of module.issues)totalsByType[issue.type]+=1;}const topHotspots=modules.map((module)=>({module:module.name,impact:module.scores.impact,risk:module.scores.risk})).slice(0,10);return{totalsByType,topHotspots,roadmapPhases:[]};};
const buildRoadmap=(modules:Report["modules"]):RoadmapPhase[]=>{const allIssues=modules.flatMap((module)=>module.issues);const phase=(name:string,filter:(t:string)=>boolean):RoadmapPhase=>({name,items:allIssues.filter((issue)=>filter(issue.type)).slice(0,10).map((issue)=>`${issue.title} (${issue.file}:${issue.startLine}) [${issue.priority}]`)});return[phase("Phase 1 (Low-risk wins)",(t)=>["unused","dead","deprecated","duplication"].includes(t)),phase("Phase 2 (Moderate)",(t)=>["complexity","coupling","consistency"].includes(t)),phase("Phase 3 (Higher-risk)",()=>true)];};
const runScan=async(configPath:string,rootOverride?:string,outDir?:string)=>{const config=loadConfig(configPath);const root=rootOverride??config.root??".";const reportDir=outDir??config.reportDir??"reports";const absRoot=path.resolve(root);const files=listFiles(absRoot,config.extensions,config.ignore);const ctx={root:absRoot,files,entrypoints:config.entrypoints.map((entry)=>path.resolve(absRoot,entry)),config:{duplicationMinLines:config.duplication.minLines,complexityMaxBranches:config.complexity.maxBranches,couplingMaxImports:config.coupling.maxImports,enableExternalTools:config.enableExternalTools}};const issues=await runDetectors(ctx);const modules=groupByModule(issues);const summary=summaryFromModules(modules);summary.roadmapPhases=buildRoadmap(modules);const report:Report={generatedAt:new Date().toISOString(),modules,summary};writeJsonReport(report,reportDir);return report;};
const runReport=(inputPath:string,outDir:string)=>{const report=JSON.parse(fs.readFileSync(inputPath,"utf8")) as Report;writeMarkdownReport(report,outDir);};
const runRoadmap=(inputPath:string,outDir:string)=>{const report=JSON.parse(fs.readFileSync(inputPath,"utf8")) as Report;const phases=buildRoadmap(report.modules);const content=["# Cleanup Roadmap","",...phases.map((phase)=>`## ${phase.name}\n${phase.items.map((item)=>`- [ ] ${item}`).join("\n")}`),"",].join("\n");fs.mkdirSync(outDir,{recursive:true});fs.writeFileSync(path.join(outDir,"roadmap.md"),content);};
const main=async()=>{const args=parseArgs(process.argv.slice(2));const configPath=args.configPath??"tools/analysis/analysis.config.json";const reportDir=args.outDir??"reports";if(args.command==="scan")return runScan(configPath,args.root,reportDir);if(args.command==="report")return runReport(path.join(reportDir,"analysis.json"),reportDir);if(args.command==="roadmap")return runRoadmap(path.join(reportDir,"analysis.json"),reportDir);process.stderr.write(`Unknown command: ${args.command}\n`);process.exit(1);};
main().catch((err)=>{process.stderr.write(`${err}\n`);process.exit(1);});
