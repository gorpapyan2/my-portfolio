import path from "path";
import { Issue, IssueEvidence, IssueType } from "../types.js";
import { suggest } from "../suggestions.js";
import { scoreIssue } from "../risk_model.js";
import { readLines, readText, toPosix } from "../utils/fs.js";
import { gitAgeDays, gitChurn } from "../utils/git.js";
import { runDuplication } from "../detectors/duplication.js";
import { runUnused } from "../detectors/unused.js";
import { runDeprecated } from "../detectors/deprecated.js";
import { runDeadcode } from "../detectors/deadcode.js";
import { runComplexity } from "../detectors/complexity.js";
import { runConsistency } from "../detectors/consistency.js";
export type RawIssue={type:IssueType;title:string;file:string;startLine:number;endLine:number;evidence?:IssueEvidence;};
export type DetectorContext={root:string;files:string[];entrypoints:string[];config:{duplicationMinLines:number;complexityMaxBranches:number;couplingMaxImports:number;enableExternalTools:boolean;}};
const excerpt=(filePath:string,startLine:number,endLine:number)=>{const lines=readLines(filePath);const start=Math.max(1,startLine);const end=Math.min(lines.length,endLine);return lines.slice(start-1,end).join("\n");};
const issueId=(type:IssueType,file:string,startLine:number)=>`${type}:${toPosix(file)}:${startLine}`;
const withGitEvidence=(filePath:string,evidence:IssueEvidence={})=>({ ...evidence, ageDays: gitAgeDays(filePath), churn: gitChurn(filePath) });
const normalize=(raw:RawIssue):Issue=>{const evidence=withGitEvidence(raw.file,raw.evidence);const scores=scoreIssue(evidence);return{id:issueId(raw.type,raw.file,raw.startLine),type:raw.type,title:raw.title,file:toPosix(raw.file),startLine:raw.startLine,endLine:raw.endLine,excerpt:excerpt(raw.file,raw.startLine,raw.endLine),evidence,impact:scores.impact,risk:scores.risk,priority:scores.priority,suggestions:suggest(raw.type)};};
export const runDetectors=async(ctx:DetectorContext):Promise<Issue[]>=>{const results:RawIssue[]=[];results.push(...(await runDuplication(ctx)),...(await runUnused(ctx)),...(await runDeprecated(ctx)),...(await runDeadcode(ctx)),...(await runComplexity(ctx)),...(await runConsistency(ctx)));return results.map(normalize);};
export const inferPublicApi=(filePath:string)=>{const normalized=toPosix(filePath);return normalized.includes("/src/components/")||normalized.includes("/src/pages/")||normalized.includes("/src/lib/");};
export const scanImports=(files:string[])=>{const map=new Map<string,Set<string>>();const byBasename=new Map<string,string>();for(const file of files)byBasename.set(path.basename(file,path.extname(file)),file);for(const file of files){const text=readText(file);const matches=Array.from(text.matchAll(/(?:from|require)\s*\(?["']([^"']+)["']/g));for(const match of matches){const raw=match[1];if(!raw.startsWith("."))continue;const base=path.basename(raw);const resolved=byBasename.get(base)??"";if(!resolved)continue;if(!map.has(resolved))map.set(resolved,new Set());map.get(resolved)?.add(file);}}return map;};
